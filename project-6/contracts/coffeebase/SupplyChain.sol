pragma solidity ^0.5.16;

import "../coffeecore/Ownable.sol";
import "../coffeeaccesscontrol/FarmerRole.sol";
import "../coffeeaccesscontrol/RetailerRole.sol";
import "../coffeeaccesscontrol/ConsumerRole.sol";
import "../coffeeaccesscontrol/DistributorRole.sol";
// Define a contract 'Supplychain'
contract SupplyChain is Ownable, FarmerRole, DistributorRole, RetailerRole, ConsumerRole {

  // Define a variable called 'upc' for Universal Product Code (UPC)
  uint  upc;

  // Define a variable called 'sku' for Stock Keeping Unit (SKU)
  uint  sku;

  // Define a public mapping 'items' that maps the SKU to an Item.
  mapping (uint => Item) items;

  // Define a public mapping 'itemsHistory' that maps the SKU to an array of TxHash, 
  // that track its journey through the supply chain -- to be sent from DApp.
  mapping (uint => string[]) itemsHistory;

  // Define enum 'State' with the following values:
  enum State 
  { 
    Harvested,  // 0
    Processed,  // 1
    Packed,     // 2
    ForSale,    // 3
    Sold,       // 4
    Shipped,    // 5
    Received,   // 6
    Purchased   // 7
    }

  State constant defaultState = State.Harvested;

  // Define a struct 'Item' with the following fields:
  struct Item {
    uint    sku;  // Stock Keeping Unit (SKU)
    uint    upc; // Universal Product Code (UPC), generated by the Farmer, goes on the package, can be verified by the Consumer
    address payable ownerID;  // Metamask-Ethereum address of the current owner as the product moves through 8 stages
    address payable originFarmerID; // Metamask-Ethereum address of the Farmer
    string  originFarmName; // Farmer Name
    string  originFarmInformation;  // Farmer Information
    string  originFarmLatitude; // Farm Latitude
    string  originFarmLongitude;  // Farm Longitude
    uint    productID;  // Product ID potentially a combination of upc + sku
    string  productNotes; // Product Notes
    uint    productPrice; // Product Price
    State   itemState;  // Product State as represented in the enum above
    address payable distributorID;  // Metamask-Ethereum address of the Distributor
    address payable retailerID; // Metamask-Ethereum address of the Retailer
    address payable consumerID; // Metamask-Ethereum address of the Consumer
  }

  // Define 8 events with the same 8 state values and accept 'upc' as input argument
  event Harvested(uint sku);
  event Processed(uint sku);
  event Packed(uint sku);
  event ForSale(uint sku);
  event Sold(uint sku);
  event Shipped(uint sku);
  event Received(uint sku);
  event Purchased(uint sku);


  // Define a modifer that verifies the Caller
  modifier verifyCaller (address _address) {
    require(msg.sender == _address); 
    _;
  }

  // Define a modifier that checks if the paid amount is sufficient to cover the price
  modifier paidEnough(uint _sku) { 
    require(msg.value >= items[_sku].productPrice); 
    _;
  }
  
  // Define a modifier that checks the price and refunds the remaining balance
  modifier checkValue(uint _sku) {
    _;
    uint _price = items[_sku].productPrice;
    uint amountToReturn = msg.value - _price;
    msg.sender.transfer(amountToReturn);
  }

  // Define a modifier that checks if an item.state of a upc is Harvested
  modifier harvested(uint _sku) {
    require(items[_sku].itemState == State.Harvested, "Item needs to be in state 'Harvested'");
    _;
  }

  // Define a modifier that checks if an item.state of a upc is Processed
  modifier processed(uint _sku) {
		require(items[_sku].itemState == State.Processed, "Item needs to be in state 'Processed'");
    _;
  }
  
  // Define a modifier that checks if an item.state of a upc is Packed
  modifier packed(uint _sku) {
		require(items[_sku].itemState == State.Packed, "Item needs to be in state 'Packed'");
    _;
  }

  // Define a modifier that checks if an item.state of a upc is ForSale
  modifier forSale(uint _sku) {
		require(items[_sku].itemState == State.ForSale, "Item needs to be in state 'ForSale'");
    _;
  }

  // Define a modifier that checks if an item.state of a upc is Sold
  modifier sold(uint _sku) {
		require(items[_sku].itemState == State.Sold, "Item needs to be in state 'Sold'");
    _;
  }
  
  // Define a modifier that checks if an item.state of a upc is Shipped
  modifier shipped(uint _sku) {
		require(items[_sku].itemState == State.Shipped, "Item needs to be in state 'Shipped'");
    _;
  }

  // Define a modifier that checks if an item.state of a upc is Received
  modifier received(uint _sku) {
		require(items[_sku].itemState == State.Received, "Item needs to be in state 'Received'");
    _;
  }

  // Define a modifier that checks if an item.state of a upc is Purchased
  modifier purchased(uint _sku) {
    require(items[_sku].itemState == State.Purchased, "Item needs to be in state 'Purchased'");
    _;
  }

  // Define a modifier that checks if an item.state of a upc is Purchased
  modifier onlyOriginFarmer(uint _sku) {
    require(items[_sku].originFarmerID == msg.sender, "Can be called by origin farmer only");
    _;
  }

  // In the constructor set 'owner' to the address that instantiated the contract
  // and set 'sku' to 1
  // and set 'upc' to 1
  constructor() Ownable() public payable {
    sku = 1;
  }


	function logItemTransaction(uint _sku, string memory _notes) public {
		string[] storage logs = itemsHistory[_sku];
		logs.push(_notes);
	}

  // Define a function 'harvestItem' that allows a farmer to mark an item 'Harvested'
  function harvestItem (
		uint _upc, 
		address payable _originFarmerID, 
		string memory _originFarmName, 
		string memory _originFarmInformation, 
		string memory _originFarmLatitude, 
		string memory _originFarmLongitude, 
		string memory _productNotes
	)
	onlyFarmer() 
	public returns (uint)
  {
		require(_originFarmerID == msg.sender, "Sender must be farmer");
    Item memory item = Item({
			sku: sku,
			upc: _upc,
			ownerID: _originFarmerID,
			originFarmerID: _originFarmerID,
			originFarmName: _originFarmName,
			originFarmInformation: _originFarmInformation,
			originFarmLatitude: _originFarmLatitude,
			originFarmLongitude: _originFarmLongitude,
			productNotes: _productNotes,
			productID: _upc,
			productPrice: 0,
			itemState: State.Harvested,
			distributorID: address(0),
			retailerID: address(0),
			consumerID: address(0)
		});

		items[sku] = item;
    sku = sku + 1;    // Increment sku
		emit Harvested(item.sku);
    return item.sku;
  }

  // Define a function 'processtItem' that allows a farmer to mark an item 'Processed'
  function processItem(uint _sku) 
	harvested(_sku)
	onlyOriginFarmer(_sku)
	public 
  {
    Item storage item = items[_sku];
		item.itemState = State.Processed;
    emit Processed(_sku);
  }

  // Define a function 'packItem' that allows a farmer to mark an item 'Packed'
  function packItem(uint _sku) public 
	processed(_sku)
	onlyOriginFarmer(_sku)
  {
    Item storage item = items[_sku];
		item.itemState = State.Packed;
    emit Packed(_sku);    
  }

  // Define a function 'sellItem' that allows a farmer to mark an item 'ForSale'
  function sellItem(uint _sku, uint _price) public 
  packed(_sku)
	onlyOriginFarmer(_sku)
  {
		Item storage item = items[_sku];
		item.itemState = State.ForSale;
		item.productPrice = _price;
    emit ForSale(_sku);
  }

  // Define a function 'buyItem' that allows the disributor to mark an item 'Sold'
  // Use the above defined modifiers to check if the item is available for sale, if the buyer has paid enough, 
  // and any excess ether sent is refunded back to the buyer
  function buyItem(uint _sku) public payable 
	onlyDistributor()
	forSale(_sku)
	paidEnough(_sku)
	checkValue(_sku)
	{
    Item storage item = items[_sku];
		item.itemState = State.Sold;
		item.ownerID = msg.sender;
		item.distributorID = msg.sender;
		item.originFarmerID.transfer(item.productPrice);
    emit Sold(_sku);
  }

  // Define a function 'shipItem' that allows the distributor to mark an item 'Shipped'
  // Use the above modifers to check if the item is sold
  function shipItem(uint _sku) public 
	onlyDistributor()
	sold(_sku)
	{
    Item storage item = items[_sku];
		item.itemState = State.Shipped;
    emit Shipped(_sku);
  }

  // Define a function 'receiveItem' that allows the retailer to mark an item 'Received'
  // Use the above modifiers to check if the item is shipped
  function receiveItem(uint _sku) public 
	onlyRetailer()
	shipped(_sku)
	{
		Item storage item = items[_sku];
		item.itemState = State.Received;
		item.ownerID = msg.sender;
		item.retailerID = msg.sender;
    emit Received(sku);   
  }

  // Define a function 'purchaseItem' that allows the consumer to mark an item 'Purchased'
  // Use the above modifiers to check if the item is received
  function purchaseItem(uint _sku) public payable
	onlyConsumer()
  received(_sku)
	paidEnough(_sku)
	checkValue(_sku)
	{
		Item storage item = items[_sku];
		item.itemState = State.Purchased;
		item.ownerID = msg.sender;
		item.consumerID = msg.sender;
    emit Purchased(sku); 
    // Update the appropriate fields - ownerID, consumerID, itemState
    
    // Emit the appropriate event
    
  }

  // Define a function 'fetchItemBufferOne' that fetches the data
  function fetchItemBufferOne(uint _sku) public view returns 
  (
  uint    itemSKU,
  uint    itemUPC,
  address ownerID,
  address originFarmerID,
  string  memory originFarmName,
  string  memory originFarmInformation,
  string  memory originFarmLatitude,
  string  memory originFarmLongitude
  ) 
	{
		Item memory item = items[_sku];

		itemSKU = item.sku;
		itemUPC = item.upc;
		ownerID = item.ownerID;
		originFarmerID = item.originFarmerID;
		originFarmName = item.originFarmName;
		originFarmInformation = item.originFarmInformation;
		originFarmLatitude = item.originFarmLatitude;
		originFarmLongitude = item.originFarmLongitude;
		
		return 
		(
		itemSKU,
		itemUPC,
		ownerID,
		originFarmerID,
		originFarmName,
		originFarmInformation,
		originFarmLatitude,
		originFarmLongitude
		);
  }

  // Define a function 'fetchItemBufferTwo' that fetches the data
  function fetchItemBufferTwo(uint _sku) public view returns 
  (
		uint    itemSKU,
		uint    itemUPC,
		uint    productID,
		string  memory productNotes,
		uint    productPrice,
		uint    itemState,
		address distributorID,
		address retailerID,
		address consumerID
		) 
	{
			// Assign values to the 9 parameters
		Item memory item = items[_sku];

		itemSKU = item.sku;
		itemUPC = item.upc;
		productID = item.productID;
		productNotes = item.productNotes;
		productPrice = item.productPrice;
		itemState = uint(item.itemState);
		distributorID = item.distributorID;
		retailerID = item.retailerID;
		consumerID = item.consumerID;
    
		return 
		(
		itemSKU,
		itemUPC,
		productID,
		productNotes,
		productPrice,
		itemState,
		distributorID,
		retailerID,
		consumerID
		);
  }


	function getRoles() public view returns (bool hasFarmerRole, bool hasDistributorRole, bool hasRetailerRole, bool hasConsumerRole) {
		hasFarmerRole = isFarmer(msg.sender) == true;
		hasDistributorRole = isDistributor(msg.sender) == true;
		hasRetailerRole = isRetailer(msg.sender) == true;
		hasConsumerRole = isConsumer(msg.sender) == true;
	}

}
